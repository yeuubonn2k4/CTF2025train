<img width="646" height="872" alt="image" src="https://github.com/user-attachments/assets/eb5ea03f-de28-48d6-a011-4b9f9c695ae7" />

<img width="657" height="766" alt="image" src="https://github.com/user-attachments/assets/1e86b7a0-8e3a-4d85-a2b1-0e225ae38573" />

<img width="940" height="700" alt="image" src="https://github.com/user-attachments/assets/23b5447b-7c32-41b5-8654-b40d5b178882" />

- Các bước khai thác EternalBlue:

1. Xác định mục tiêu: Quét các hệ thống chạy windows xem cái nào dễ bị tấn công có bật SMBv1.

2. Thực hiện khai thác: Gửi các gói SMB độc hại kích hoạt lỗ hổng trong SMBv1.

3. Truy cập từ xa: Nhận các đặc quyền cấp hệ thống trên máy mục tiêu mà không cần thông tin xác thực.

# NTLM (New Technology LAN Manager) được dùng để xác thực danh tính người dùng và bảo vệ tính toàn vẹn, bảo mật các hoạt động trên mạng thông qua cơ chế "thử thách-phản hồi". 

# Kerberos được sử dụng để xác thực an toàn các yêu cầu dịch vụ trên mạng không an toàn thông qua cơ chế "vé" (ticket). Nó cho phép cả người dùng và máy chủ xác minh danh tính của nhau mà không gửi mật khẩu qua mạng, từ đó ngăn chặn các cuộc tấn công nghe lén và phát lại gói tin.

<img width="641" height="575" alt="image" src="https://github.com/user-attachments/assets/a02527a4-3ab9-40df-8772-9f762e915e0c" />

<img width="674" height="600" alt="image" src="https://github.com/user-attachments/assets/2cb1f640-f38a-40de-bcce-dd4ea5d400e8" />

- Tập lệnh kiểm tra xem máy chủ có dễ bị tấn công bởi MS17-010 (EternalBlue) hay không:

<img width="927" height="483" alt="image" src="https://github.com/user-attachments/assets/1e7223c3-e6e6-48cb-9e4c-a5d10c24a44e" />

<img width="926" height="767" alt="image" src="https://github.com/user-attachments/assets/1f3aea5e-3da2-499e-8462-bb7b1bd4e8e0" />

<img width="926" height="767" alt="image" src="https://github.com/user-attachments/assets/2c132a7d-852d-4b00-852c-17ab64b8fdd2" />

<img width="678" height="857" alt="image" src="https://github.com/user-attachments/assets/a6466c20-a311-4d63-b5f1-ca187146c75d" />

- My question:

```
theo mình hiểu ở cái Metasploit này dựa theo kết quả trả về là: đầu tiên nó sẽ kết nối đến targer muốn exploitation, sau đó thiết lập việc exploitation, sau đó xem phiên bản SMB mà hệ điều hành mục tiêu đã chọn, sau đó dump dữ liệu, thông tin, version của hệ điều hành mục tiêu. sau đó cố khai thác với 12 Broom Application.  Sau đó gửi tất cả các gói tin nhưng không gửi gói tin khai thác cuối. Sau đó bắt đầu 1 cái non pool groom, và gửi các gói SMbv2 rồi đóng kết nối SMBv1 và tạo ra 1 cái đường cho SMBv2 vào tấn công. Sau đó gửi tất cả liên quan đến SMBv2 rồi cuối cùng với gửi gói tin khai thác cuối của SMBv1 lúc trước chưa gửi. Sau đó sẽ nhận được kết quả từ gói tin khai thác cuối trả về. Lúc này lỗ hổng EternalBlue đã được ghi vào thành công. Sau đó gửi yêu cầu muốn dừng kết nối. Này đung không
```

-> Correct answer:

```
Xác nhận tóm tắt (đúng)

Metasploit trước hết kiểm tra (scan / probe) host để xác định xem target có phản hồi và có dấu hiệu của MS17-010 hay không.

Nếu thấy dấu hiệu khả nghi, framework sẽ kết nối tới dịch vụ SMB và cố gắng thiết lập điều kiện để khai thác (tương tự như “chuẩn bị” / “handshake” với target).

Nó xác định một số thông tin mục tiêu (phiên bản OS/SMB, kiến trúc) từ phản hồi để chọn biến thể exploit phù hợp.

Sau đó tiến hành một loạt thao tác “grooming”/“spray”: gửi nhiều gói/khối dữ liệu để tạo ra một trạng thái bộ nhớ/heap có thể dự đoán được trên máy mục tiêu (để khi gửi gói khai thác cuối cùng, overwrite sẽ dẫn tới RCE thay vì crash).

Cuối cùng exploit gửi gói kích hoạt cuối (the final trigger). Nếu thành công, máy mục tiêu sẽ nhận stage (ví dụ Meterpreter) và một session ngược (reverse shell) được mở trên handler của bạn.

Log bạn chụp cho thấy exploit báo “ETERNALBLUE overwrite completed successfully” và “Meterpreter session X opened” — nghĩa là exploit trên ví dụ đó đã thành công (với rủi ro target bị crash nếu không thành công).

Làm rõ / sửa một vài điểm (tránh hiểu sai kỹ thuật)

“Dump dữ liệu, thông tin, version”: framework thu thập một số thông tin từ phản hồi SMB (như banner, OS build) — đây là fingerprinting, không phải dump toàn bộ hệ thống.

“12 Groom Allocations” hay “non-paged pool grooming”: đó là thuật ngữ mô tả kỹ thuật heap grooming (tạo/sắp xếp các khối bộ nhớ theo kiểu nhất định). Con số/chi tiết là cách implement cụ thể của exploit chứ không phải một quy trình tiêu chuẩn cho tất cả exploit.

Việc gửi “SMBv2 buffers” rồi “đóng kết nối SMBv1 tạo free hole adjacent to SMBv2 buffer” — đó là mô tả một chiến lược tạo layout bộ nhớ “liền kề” giữa các vùng do SMBv1/SMBv2 quản lý, để khi gửi trigger overwrite sẽ ăn vào vùng đã chuẩn bị. Đây là kỹ thuật khai thác bộ nhớ chứ không phải “chuyển đường” mạng hay giao thức theo nghĩa đơn giản.

“Gửi tất cả các gói nhưng không gửi gói tin khai thác cuối” — framework làm nhiều bước chuẩn bị rồi mới gửi trigger; logs bạn thấy là bản tóm tắt các bước này, không phải từng byte gói tin.
```

=> Hiểu cơ bản của bạn là đúng: Metasploit probe → fingerprint → heap grooming / chuẩn bị → gửi trigger cuối → nếu thành công gửi stage và mở session. Những cụm từ như “12 Groom Allocations”, “non-paged pool grooming”, “SMBv2 buffers” là chi tiết triển khai của exploit (kỹ thuật heap manipulation) chứ không phải các bước chung áp dụng cho mọi lỗ hổng.

=> Cần nhớ:

### “grooming”/“spray”: gửi nhiều gói/khối dữ liệu để tạo ra một trạng thái bộ nhớ/heap có thể dự đoán được trên máy mục tiêu (để khi gửi gói khai thác cuối cùng, overwrite sẽ dẫn tới RCE thay vì crash).

```
1) Mục tiêu của grooming / spray là gì?

Mục đích chính: biến trạng thái heap không thể dự đoán của hệ thống thành một trạng thái có thể dự đoán — tức biết được kích thước, vị trí và nội dung của các vùng nhớ (chunks/objects) sao cho khi ta thực hiện một ghi đè (overflow/overwrite) thì:

Ghi đè “chỉ” ảnh hưởng tới trường/byte mục tiêu (ví dụ vtable pointer, function pointer, saved return pointer, metadata) mà attacker muốn kiểm soát, và

Sau khi ghi đè, giá trị bị ghi là có lợi cho attacker (ví dụ trỏ tới vùng dữ liệu do attacker kiểm soát hoặc tới ROP gadget hợp lệ).

Nếu không grooming, ghi đè có thể phá hủy cấu trúc ngẫu nhiên, dẫn tới crash.

2) Cách grooming dẫn tới RCE — nguyên lý (mức khái quát, không có payload / code)

Tạo/điều hướng layout: attacker gửi nhiều request để allocate/free các khối nhớ theo thứ tự/size mong muốn (heap feng shui). Mục tiêu là tạo “lỗ” (holes) và khối liền kề theo kiểu có lợi.

Spraying: attacker fill (spray) các vùng nhớ bằng dữ liệu có cấu trúc do attacker kiểm soát (ví dụ fake object, fake vtable, controlled pointers). Điều này giúp đảm bảo khi một pointer/vtable bị redirect, nó trỏ vào dữ liệu attacker đã đặt.

Trigger overwrite: exploit gửi gói trigger cuối để gây overflow/overwrite một pointer/metadata đã được định vị trước đó (do grooming). Bởi vì attacker đã biết layout và đã đặt dữ liệu ở vị trí dự đoán, overwrite thường thay thế pointer bằng một giá trị attacker-chọn.

Kích hoạt: sau overwrite, server tiếp tục dùng pointer/vtable/structure đã bị thay — và do pointer trỏ tới code/data attacker-chọn, hành vi tiếp theo làm CPU thực thi chuỗi lệnh do attacker kiểm soát hoặc thực hiện một ROP chain => dẫn tới RCE.

Quan trọng: grooming là cách làm cho overwrite trở nên có mục tiêu và đáng tin cậy, không phải phép màu — exploit cần hiểu chi tiết allocator, kích thước chunks, behavior của hệ thống để thành công.

3) Tại sao nếu không grooming thì thường crash?

Heap allocator trả về khối nhớ ở những vị trí không lường trước; overwrite sẽ hỏng metadata/structure không mong muốn → kernel/user process bị corruption, dẫn tới crash hoặc kernel panic.

Pointer/vtable bị overwrite thành giá trị ngẫu nhiên → khi được dereference sẽ truy cập địa chỉ không hợp lệ → fault và crash.

Không có dữ liệu “shellcode” ở vị trí trỏ tới → không có mã hợp lệ để thực thi.

Grooming làm giảm những yếu tố ngẫu nhiên đó.

4) Các kỹ thuật bổ trợ để chuyển từ overwrite có kiểm soát → RCE

(Chỉ nêu tên/ý tưởng, không hướng dẫn thực thi)

Fake objects / vtable overwrite: thay vtable pointer để khi gọi method thì nó dùng code do attacker kiểm soát.

Function pointer overwrite: redirect hàm callback sang dữ liệu do attacker kiểm soát.

Heap-spray đặt shellcode (trong môi trường thiếu NX) hoặc đặt pointer tới vùng có ROP chain.

ROP (Return-Oriented Programming) để vượt qua bảo vệ NX/DEP: thay vì chạy shellcode trực tiếp, chuỗi gadgets hợp lệ được kết nối để thực thi logic mong muốn.

Leaking pointers: exploit thường cần leak pointer kernel/user (để biết base addresses khi ASLR bật). Grooming + leak giúp tính toán địa chỉ chính xác.

Timing/race control: một số exploit cần điều khiển thứ tự/độ trễ giữa allocations và frees.
```

- Khác với: "Spraying attack" (tấn công phun mật khẩu) là một phương thức tấn công mạng trong đó kẻ tấn công sử dụng một vài mật khẩu phổ biến để thử đăng nhập vào nhiều tài khoản người dùng khác nhau. Mục đích của việc này là để tránh bị khóa tài khoản, một biện pháp phòng ngừa an ninh thường xảy ra khi thử nhiều mật khẩu cho một tài khoản duy nhất. 

```
Giải thích ngắn các dòng log bạn chụp

ETERNALBLUE overwrite completed successfully — đây là bước ghi đè (corruption) có chủ đích vào metadata/struct/pointer trên heap mà exploit nhắm tới. Mục tiêu của bước này không phải chạy mã ngay lập tức mà là thay đổi cấu trúc bộ nhớ theo cách có lợi (ví dụ: thay vtable pointer, function pointer, size field, hoặc thông tin allocator).

Sending egg to corrupted connection. — “egg” là thuật ngữ chung cho dữ liệu do attacker kiểm soát (có thể là shellcode, ROP chain, hoặc đơn giản là một block dữ liệu chứa con trỏ hợp lệ). Có hai cách phổ biến exploit dùng “egg” này:

Egg đã được đặt trước (spray): exploit trước đó đã “spray”/fill một vùng heap bằng dữ liệu của attacker. Khi overwrite thay đổi pointer để trỏ tới vùng đó, việc “sending egg” có thể là viết marker/trigger nhỏ vào connection để khiến code sử dụng pointer mới này.

Egg được gửi sau overwrite: exploit vừa ghi đè metadata để tạo điều kiện, rồi trực tiếp gửi nội dung (egg) vào vùng heap đã bị điều hướng để chứa payload.

Triggering free of corrupted buffer. — thao tác free/release buộc hệ thống sử dụng metadata/buffer đã bị sửa. Khi code thực thi thao tác đó (ví dụ dereference function pointer, gọi method trên object), nếu pointer/vtable đã bị điều khiển thì control flow có thể nhảy sang vùng mà attacker đã đặt (egg) — từ đó dẫn đến thực thi mã (RCE). Nếu mọi thứ không đúng, thao tác này thường gây crash thay vì execution.

Sau khi trigger thành công — điều gì thường xảy ra (mức tổng quát)

Control flow hijack: khi kernel/process dùng field/ptr đã bị overwrite, nó sẽ nhảy/đi theo giá trị do attacker đặt (nếu layout đúng).

Stage tải lên: attacker có thể đặt một “stage” (code nhỏ hoặc chuỗi ROP) ở vị trí đã kiểm soát; hệ thống sẽ thực thi/chạy chuỗi đó hoặc sẽ chuyển điều khiển sang một ROP chain để vượt qua NX/DEP.

<img width="915" height="253" alt="image" src="https://github.com/user-attachments/assets/b507aa88-d1d6-4a26-8fbe-67c7b3db4156" />

Mở kết nối điều khiển: nếu exploit thành công, attacker thường khởi tạo một kết nối ngược (reverse shell/Meterpreter) hoặc tương tự — bạn sẽ thấy log như Meterpreter session X opened.

Hậu quả: attacker có thể thực thi mã, leo quyền, triển khai payload tiếp theo (cài backdoor, ransomware, exfiltrate data). Hoặc nếu exploit không khớp hoàn toàn, hệ thống có thể crash (BSOD/service crash).

Tóm tắt: overwrite → đặt egg/stage → trigger free → hijack control flow → (nếu thành công) thực thi stage → session/remote control.
```

<img width="915" height="253" alt="image" src="https://github.com/user-attachments/assets/2b1b92b1-bf76-4788-ac33-3c0a68b1c964" />



